---
title: "RF_SMDW_final"
author: "Esther Greenwood"
output: html_document
---
# Modelling Safely Managed Drinking Water in low and middle income countries

Here we model access to safely managed drinking water (SMDW) using random forest models with Earth Observation and Multiple Indicator Cluster Survey (MICS) data.

```{r}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, root.dir = 
"C:/Users/Esther/Documents/GitHub/MICS_SMDW")

library(data.table)
library(tidyverse)
library(h2o)
library(dplyr)
library(here)
```

##Loading ("reading") Data and joining data sets

```{r}
source("~/GitHub/MICS_SMDW/Data_cleaning/MICS_Preprocessing_Dataframes/Compiling_MICS_test_and_training_sets/functionsForJoiningAndStructuringDataframes.R")

UN_Population_Devision_Names <- readCountryNamesOfUNPopulationDivisionWorldPopulationProspects()

EO_features <- readEarthObservationFeaturesAndRenameCountriesAccordingToUN_WPP()

df.MICS_HH <- readHouseHoldSurveyData() 

country_Income_Groups <- readCountryIncomeGroup()

```

##Creating SMDW indicator

Here we create indicators for safely managed drinking water (SMDW) based on the criteria defined by the Framework of the Joint Monitoring Program. For drinking water to be safely managed survey responses must indicate that it is (1) free from E.coli contamination at the point of collection, (2) accessible in house or on plot, (3) taken from an improved water source and (4) household members must not have experience water insufficiency within the last month.

```{r}
source("~/GitHub/MICS_SMDW/Data_cleaning/MICS_Preprocessing_Dataframes/CreatingSMDWIndicator.R")

df.MICS_HH_SMDW <- creatingSMDWIndicators(df.MICS_HH)

SMDW_training <- createIndicatorForRegionalSMDWCoverage(df.MICS_HH_SMDW)

```

Combining SMDW indicator from MICS data with earth observation data 
```{r}
EO_features <- renameDuplicateHH7RegionNamesFromDifferentCountries(EO_features)

source("~/GitHub/MICS_SMDW/Training/feature_names/24_features.r")
source("~/GitHub/MICS_SMDW/Training/feature_names/39_features.R")
source("~/GitHub/MICS_SMDW/Training/feature_names/51_features.R")
source("~/GitHub/MICS_SMDW/Training/feature_names/73_features.R")
source("~/GitHub/MICS_SMDW/Training/feature_names/91_features.R")
source("~/GitHub/MICS_SMDW/Training/feature_names/117_features.R")

# environmental and human features
combined_SMDW_envir_human_24 <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_24)

combined_SMDW_envir_human_39 <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_39)

combined_SMDW_envir_human_51 <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_51)

combined_SMDW_envir_human_73 <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_73)

combined_SMDW_envir_human_117 <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_117)

# only human features from final feature set
combined_SMDW_human <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_Human)

# only environmental features from final feature set
combined_SMDW_envir <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_Environmental)

```

##Random Forest Modelling

##Feature selection

Here we run 5 random forest models with default parameters and different feature sets with 117, 73, 51, 39 and 24 features.

```{r}

h2o.init(nthreads = 7, max_mem_size = '8g', ignore_config = TRUE)

#random forest model with all 117 pre-selected features

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'


#number countries for cross validation fold assignment

combined_SMDW_envir_human_117 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_117)
                             
# select only variables needed for random forest models  

combined_SMDW_envir_regMatrix_117 <- combined_SMDW_envir_human_117%>%
  select(all_of(bandNames_117),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)%>% drop_na(country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_117 <- as.h2o(combined_SMDW_envir_regMatrix_117, destination_frame = "regMatrixH2O_SMDW_117")


# random forest regression

rf_model_SMDW_117 <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_117,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_117, xval = TRUE)
h2o.mae(rf_model_SMDW_117,xval = TRUE)

h2o.shutdown()
```
```{r}
h2o.init(nthreads = 7, max_mem_size = '8g', ignore_config = TRUE)

#random forest model with 73 pre-selected features

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'


#number countries for cross validation fold assignment

combined_SMDW_envir_human_73 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_73)
                             
# select only variables needed for random forest models  

combined_SMDW_envir_regMatrix_73 <- combined_SMDW_envir_human_73%>%
  select(all_of(bandNames_73),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)%>% drop_na(country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_73 <- as.h2o(combined_SMDW_envir_regMatrix_73, destination_frame = "regMatrixH2O_SMDW_73")


# random forest regression

rf_model_SMDW_73 <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_73,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_73, xval = TRUE)
h2o.mae(rf_model_SMDW_73, xval=TRUE)

```
```{r}
#random forest model with 51 pre-selected features

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'


#number countries for cross validation fold assignment

combined_SMDW_envir_human_51 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_51)
                             
# select only variables needed for random forest models  

combined_SMDW_envir_regMatrix_51 <- combined_SMDW_envir_human_51%>%
  select(all_of(bandNames_51),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)%>% drop_na(country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_51 <- as.h2o(combined_SMDW_envir_regMatrix_51, destination_frame = "regMatrixH2O_SMDW_51")


# random forest regression

rf_model_SMDW_51 <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_51,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_51, xval = TRUE)
h2o.mae(rf_model_SMDW_51, xval=TRUE)
```
```{r}
#random forest model with 39 pre-selected features

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'

#number countries for cross validation fold assignment

combined_SMDW_envir_human_39 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_39)
                             
# select only variables needed for random forest models  

combined_SMDW_envir_regMatrix_39 <- combined_SMDW_envir_human_39%>%
  select(all_of(bandNames_39),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)%>% drop_na(country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_39 <- as.h2o(combined_SMDW_envir_regMatrix_39, destination_frame = "regMatrixH2O_SMDW_39")

# random forest regression

rf_model_SMDW_39 <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_39,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_39, xval = TRUE)
h2o.mae(rf_model_SMDW_39, xval=TRUE)
```
```{r}
#random forest model with 24 pre-selected features

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'

#number countries for cross validation fold assignment

combined_SMDW_envir_human_24 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_24)
                             
# select only variables needed for random forest models  

combined_SMDW_envir_regMatrix_24 <- combined_SMDW_envir_human_24%>%
  select(all_of(bandNames_24),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)%>% drop_na(country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_24 <- as.h2o(combined_SMDW_envir_regMatrix_24, destination_frame = "regMatrixH2O_SMDW_39")

# random forest regression

rf_model_SMDW_24 <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_24,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_24, xval = TRUE)
h2o.mae(rf_model_SMDW_24, xval=TRUE)

h2o.shutdown()
```

##Grid-search: Tuning hyperparameters of random forest model with 39 features
```{r}
## grid-search to iteratively explore the results of a suite of random forest models trained on the selected covariates. A list of hyperparameters was selected, varying in (1) the number of trees, (2) the number of variables sampled at each split  and (3) the minimum observations per leaf and (4)sampling rate

h2o.init(nthreads = 7, max_mem_size = '8g', ignore_config = TRUE)

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'

combined_SMDW_envir_human_39 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_39)

combined_SMDW_envir_human_39 <- combined_SMDW_envir_human_39 %>% drop_na(country_fold)
                             
# select only variables needed for random forest models  
combined_SMDW_envir_regMatrix_39 <- combined_SMDW_envir_human_39%>%
  select(all_of(bandNames_39),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_39 <- as.h2o(combined_SMDW_envir_regMatrix_39, destination_frame = "regMatrixH2O_SMDW_39")


rf.params_39<-list(ntrees = c(100,200),
                mtries = c(6,10,13,20), #(about n^(1/2), n/4, n/3, n/2 with n=number of features)
                min_rows = c(1,3,5),
                sample_rate = c(0.6,0.8)
                )

search.criteria<-list(strategy = 'RandomDiscrete', max_models = 150, seed = 0, max_runtime_secs = 3600)


rf.grid_39<-h2o.grid('randomForest',
                  y = varToModel_SMDW,
                  grid_id = 'rf.grid_39',
                  training_frame = regMatrixH2O_SMDW_39,
                  seed = 0,
                  hyper_params = rf.params_39,
                  fold_column = "country_fold",
                  weights_column = "HouseholdsInRegion.Freq.x",
                  fold_assignment = 'AUTO',
                  keep_cross_validation_predictions = TRUE,
                  keep_cross_validation_fold_assignment = TRUE,
                  search_criteria = search.criteria)

summary(rf.grid_39, show_stack_traces = TRUE)
#retrieve grid searched model performance sort by RMSE/R2

rf.grid.perf<-h2o.getGrid(grid_id = 'rf.grid_39',
                          sort_by = 'R2', # This is also coefficient of determinaion values

                                                    decreasing = TRUE)
summary(rf.grid_39, show_stack_traces = TRUE)

print(rf.grid.perf@summary_table)

#write.csv(rf.grid.perf@summary_table,"~/GitHub/MICS_SMDW/Training/rf_grid_SMDW_reg_39.csv")

```

##Best RF model for SMDW using 39 features (environmental and human indicators)
```{r}

h2o.init(nthreads = 7, max_mem_size = '8g', ignore_config = TRUE)

varToModel_SMDW <-'SMDWcoverageAtRegionalLevel'

#Important: the next 2 steps do not need to be done if the Grid Search and/ or Feature selection code chunk were run.

#1)
combined_SMDW_envir_human_39 <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir_human_39) %>% drop_na(country_fold)
                             
#2) select only variables needed for random forest models  
combined_SMDW_envir_regMatrix_39 <- combined_SMDW_envir_human_39 %>%
  select(all_of(bandNames_39),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)

#write.csv(combined_SMDW_envir_regMatrix_39, "~/GitHub/MICS_SMDW/Prediction/Regre_Matrix_SMDW.csv", fileEncoding = "UTF-8", row.names = T)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW <- as.h2o(combined_SMDW_envir_regMatrix_39, destination_frame = "regMatrixH2O_SMDW")

# random forest regression- with leave-one-country-out cross-validation

rf_model_SMDW <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW,
  ntrees = 200,
  mtries = 10,
  sample_rate = 0.6,
   min_rows = 3,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 0,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, # Important!
  keep_cross_validation_fold_assignment = TRUE,
  keep_cross_validation_models = TRUE
  )

h2o.r2(rf_model_SMDW, xval = TRUE)
h2o.mae(rf_model_SMDW, xval = TRUE)


h2o.varimp_plot(rf_model_SMDW)
h2o.varimp(rf_model_SMDW)

```

##Plot results from best RF Model for SMDWs
Plot Predicted versus Observed SMDWs usage with results from leave-one-country-out holdout predictions.
```{r}
#create data frame with validation holdout predictions, observed SMDWs values

TrainAndPredicted_SMDW <- createDataFrameWithValidationHoldOutPredictions(rf_model_SMDW, combined_SMDW_envir_human_39) 

TrainAndPredicted_SMDW <- joinWithCountryIncomeGroups(TrainAndPredicted_SMDW,UN_Population_Devision_Names, country_Income_Groups)

library("ggsci")

colours <- c("#E64B35FF", "#91D1C2FF","#3C5488FF","#4DBBD5FF", "#00A087FF")
#show_col(pal_npg("nrc")(10))

plotPredObs_SMDW <- ggplot(TrainAndPredicted_SMDW, 
                      aes(x = predict, 
                          y = SMDWcoverageAtRegionalLevel, size = NumberOfHouseholdsInRegion, colour=Income.group )) +
  geom_point(shape=1) +
  labs(x = "Predicted Proportion of Population Using SMDWs",
       y = "Observed Proportion of Population Using SMDWs") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
  stat_smooth(se = T,
              colour = "black",
              size = 0.5,
              method = "lm") +
  theme_minimal()+
  labs(size="Households in region (n)", 
       col="Income group") +
  scale_colour_manual(values = colours)


plotPredObs_SMDW

```

Create compute SHAP values and plot SHAP Contribution summary 
```{r}
shap_values_SMDW_39<- predict_contributions.H2OModel(
  rf_model_SMDW,
  regMatrixH2O_SMDW)

mean_SHAPvalues_SMDW <- as.data.frame(colMeans(abs(as.data.frame(shap_values_SMDW_39) %>% select(-BiasTerm)))); names(mean_SHAPvalues_SMDW) <- 'Mean'
mean_SHAPvalues_SMDW %>% arrange(desc(Mean))

mean_SHAPvalues_SMDW <- cbind(feature = rownames(mean_SHAPvalues_SMDW), mean_SHAPvalues_SMDW)

mean_SHAPvalues_SMDW  <- rename39Features(mean_SHAPvalues_SMDW)

mean_SHAPvalues_SMDW <- group39FeaturesInto5IndicatorGroups(mean_SHAPvalues_SMDW)


#write.csv(mean_SHAPvalues_SMDW, "~/GitHub/MICS_SMDW/Prediction/prediction-results/Shap_values_SMDW_39_newest.csv", fileEncoding = "UTF-8", row.names = T)

shap_summary_plot <- h2o.shap_summary_plot(rf_model_SMDW, regMatrixH2O_SMDW)
print(shap_summary_plot)

shap_summary_plot_data <- shap_summary_plot[['data']]
shap_summary_plot_data$feature <- as.character(shap_summary_plot_data$feature)
shap_summary_plot_data <-rename39Features(shap_summary_plot_data)

shap_summary_plot_data <- shap_summary_plot_data %>%
  left_join(mean_SHAPvalues_SMDW, by = c("feature"="feature"))

library(viridis)
shap_summary_plot_data %>%
  mutate(feature = fct_reorder(feature, Mean)) %>%
ggplot(aes(feature, contribution, color = normalized_value, text = row)) +
        geom_hline(yintercept = 0, linetype = "dashed") +
        geom_point(position = h2o:::position_jitter_density(), alpha = 0.5, size = 1.2) +
        scale_fill_gradientn(colors = viridis_pal()(9), breaks=c(0,1),labels=c("low","high"), limits=c(0, 1)) +
        coord_flip() +
        labs(y = "SHAP Contribution to SMDWs Prediction", x = "", col = "Normalized\nFeature Value") +
        theme_bw() 

```

Plotting summarized average SHAP values by Indicator Group
```{r}
library(tibble)
  
SHAP_values_SMDW_grouped <- mean_SHAPvalues_SMDW %>% 
  group_by(Indicator.Group) %>% 
  summarise(SumOfAverageSHAPValue = sum(Mean))

Plot_SHAP_SMDW_grouped <- ggplot(SHAP_values_SMDW_grouped, aes(x=reorder(Indicator.Group, SumOfAverageSHAPValue), y=SumOfAverageSHAPValue, fill= Indicator.Group)) +
  ggtitle("Use of SMDWs")+
  geom_bar(stat = "identity") + 
  labs(y = "sum of average SHAP values", x="") +
  scale_y_continuous(limits = c(0,0.150)) +
coord_flip() +
  scale_fill_manual(values=colours)+
  guides(fill = FALSE, color = FALSE, linetype = FALSE, shape = FALSE)+
  theme_bw()

Plot_SHAP_SMDW_grouped

```

##Random-fold cross validation results 
```{r}
combined_SMDW_envir_regMatrix_39_randomFold <- combined_SMDW_envir_human_39 %>%
  select(all_of(bandNames_39),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x)
  
regMatrixH2O_SMDW_randomFold <- as.h2o(combined_SMDW_envir_regMatrix_39_randomFold, destination_frame = "regMatrixH2O_SMDW_randomfoldCV")

# random forest regression- with 27-fold- leave one country out cross validation

rf_model_SMDW_randomfoldCV<- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_randomFold,
  
  ntrees = 200,
  mtries = 10,
  sample_rate = 0.6,
   min_rows = 3,
  nfolds = 27,
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 0,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, # Important!
  keep_cross_validation_fold_assignment = TRUE,
  keep_cross_validation_models = TRUE
  )

h2o.r2(rf_model_SMDW_randomfoldCV, xval = TRUE)
h2o.mae(rf_model_SMDW_randomfoldCV, xval = TRUE)

```

##Modelling with only human versus only environmental features
```{r}
#1) modelling only with human features

combined_SMDW_human <- createColumnForCVfoldBasedOnCountries(combined_SMDW_human) %>% drop_na(country_fold)
                             
# select only variables needed for random forest models  
combined_SMDW_human <- combined_SMDW_human %>%
  select(all_of(bandNames_Human),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_human <- as.h2o(combined_SMDW_human, destination_frame = "regMatrixH2O_SMDW_human")

# random forest regression- with leave-one-country-out cross-validation

rf_model_SMDW_human <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_human,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_human, xval = TRUE)
h2o.mae(rf_model_SMDW_human, xval = TRUE)


#2) modelling only with environmental features

combined_SMDW_envir <- createColumnForCVfoldBasedOnCountries(combined_SMDW_envir) %>% drop_na(country_fold)
                             
# select only variables needed for random forest models  
combined_SMDW_envir <- combined_SMDW_envir %>%
  select(all_of(bandNames_Environmental),all_of(varToModel_SMDW),HouseholdsInRegion.Freq.x, country_fold)

#save regression Matrix as H2O data frames  
regMatrixH2O_SMDW_envir <- as.h2o(combined_SMDW_envir, destination_frame = "regMatrixH2O_SMDW_envir")

# random forest regression- with leave-one-country-out cross-validation

rf_model_SMDW_envir <- h2o.randomForest(
  y = varToModel_SMDW,
  training_frame = regMatrixH2O_SMDW_envir,
  ntrees = 500,
  mtries = -1, #(number of variables/3)
  sample_rate = 0.632,
  fold_column = "country_fold",
  weights_column = "HouseholdsInRegion.Freq.x",
  seed = 123,
  fold_assignment = 'AUTO',
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE)

h2o.r2(rf_model_SMDW_envir, xval = TRUE)
h2o.mae(rf_model_SMDW_envir, xval = TRUE)
```

## Predicting SMDWs use at global administrative (GADM) area level 1

```{r}
#level 1 prediction

EO_GADM_level1 <- read.csv(here("Data/EnvironmentalFeatures/FeaturesAtGADMlevel1.csv"), encoding = "UTF-8")

regressionMatrixForPrediction <- EO_GADM_level1 %>%  
 select(all_of(bandNames_39))
 
regMatrixH2O_4pred_39 <- as.h2o(regressionMatrixForPrediction, destination_frame = "regMatrixH2O_4pred_39")
 
 # creating a dataframe with country characteristics for further descriptive analysis of predictions

FullPrediction_SMDW <- as.data.frame(h2o.predict(rf_model_SMDW, regMatrixH2O_4pred_39))
FullPrediction_SMDW$region <- EO_GADM_level1[["NAME_1"]]
FullPrediction_SMDW$GID_1 <- EO_GADM_level1[["GID_1"]]
FullPrediction_SMDW$country <- EO_GADM_level1[["NAME_0"]]
FullPrediction_SMDW$GID_0 <- EO_GADM_level1[["GID_0"]]

country_Income_Groups <- renameCountryCodeForKosovo(country_Income_Groups)

FullPrediction_SMDW <- FullPrediction_SMDW  %>% 
  left_join(country_Income_Groups, by=(c("GID_0"="Code")))

#Venezuela was not in the WB income group classification file so we add it as a lower-middle-income country according to the Inter-American Development Bank

FullPrediction_SMDW$Income.group[FullPrediction_SMDW$country == "Venezuela"] <- "Lower middle income"
FullPrediction_SMDW$Income.group[FullPrediction_SMDW$country == "Tokelau"] <- "Lower middle income"
FullPrediction_SMDW$Income.group[FullPrediction_SMDW$country == "Saint Helena"] <- "Upper middle income"

FullPrediction_SMDW <- FullPrediction_SMDW %>%
  na.omit(Income.group)

#write.csv(FullPrediction_SMDW, "~/GitHub/MICS_SMDW/Prediction/Fullprediction_SMDW_newest.csv", fileEncoding = "UTF-8", row.names = F)

```

##Uncertainty analysis
Here we calculate the Coefficient of Variation and Interquartile range across random forest models built off stratified bootstrapped samples of the training set.

```{r}
# Plotting Income level and UN region distribution in the training set

Plot_IncomeLevelDistribution <- ggplot(TrainAndPredicted_SMDW, aes(x=as.factor(Income.group), y=..count.. / sum(..count..))) +
  ggtitle("Income Group Distribution in Training Set")+
  geom_bar(fill="light blue") + 
  labs(x = "",
       y = "Proportion of Observations (subnational regions)")+
  theme_bw()
Plot_IncomeLevelDistribution

GlobalRegions <- readAndRenameStandardGlobalRegionNames()

TrainAndPredicted_SMDW_withGlobalRegions <- TrainAndPredicted_SMDW %>% left_join(GlobalRegions, by = c("ISO3.Alpha.code"="ISO.alpha3.Code"))

TrainAndPredicted_SMDW_withGlobalRegions$UNRegionName[TrainAndPredicted_SMDW_withGlobalRegions$Country == "Kosovo (under UNSC res. 1244)"] <- "Europe"

Plot_UNRegionDistribution <- ggplot(TrainAndPredicted_SMDW_withGlobalRegions, aes(x=as.factor(UNRegionName), y=..count.. / sum(..count..))) +
  ggtitle("UN Region Distribution in Training Set")+
  geom_bar(fill="light blue") + 
  labs(x = "",
       y = "Proportion of Observations (subnational regions)")+
  theme_bw()
Plot_UNRegionDistribution

summary(as.factor(TrainAndPredicted_SMDW_withGlobalRegions$UNRegionName))

#He we plot the Income and UN region distribution among the GADM level 1 regions we predict SMDWs for

#joining full prediction data from with global regions first
totalAreaOfAdminUnit_Population2020 <- EO_GADM_level1 %>% 
  select(totalAreaOfAdminUnit, GID_1, GPWv4_Population_2020)

FullPrediction_SMDW_UNGlobalRegions <- FullPrediction_SMDW %>% 
  left_join(totalAreaOfAdminUnit_Population2020, by = c("GID_1"="GID_1")) %>%
  left_join(UN_Population_Devision_Names, by = c("GID_0"="ISO3.Alpha.code")) %>%
  left_join(GlobalRegions, by = c("GID_0"="ISO.alpha3.Code")) 

FullPrediction_SMDW_UNGlobalRegions$X.U.FEFF.Country[FullPrediction_SMDW_UNGlobalRegions$country == "Kosovo"] <- "Kosovo (under UNSC res. 1244)"
  
FullPrediction_SMDW_UNGlobalRegions$UNRegionName[FullPrediction_SMDW_UNGlobalRegions$X.U.FEFF.Country == "Kosovo (under UNSC res. 1244)"] <- "Europe"

FullPrediction_SMDW_UNGlobalRegions$UNSubRegionName[FullPrediction_SMDW_UNGlobalRegions$X.U.FEFF.Country == "Kosovo (under UNSC res. 1244)"] <- "Eastern Europe"

FullPrediction_SMDW_UNGlobalRegions <- FullPrediction_SMDW_UNGlobalRegions  %>% 
  filter(Income.group == "Low income" |
         Income.group == "Lower middle income" |
         Income.group == "Upper middle income")


Plot_IncomeLevelDistribution_Prediction <- ggplot(FullPrediction_SMDW_UNGlobalRegions,   aes(x=as.factor(Income.group), y=..count.. / sum(..count..))) +
  ggtitle("Income Group Distribution in LMICs")+
  geom_bar(fill="light blue") + 
  labs(x = "",
       y = "Proportion of subnational regions for prediction")+
  theme_bw()
Plot_IncomeLevelDistribution_Prediction

Plot_UNRegionDistribution_Prediction <- ggplot(FullPrediction_SMDW_UNGlobalRegions, aes(x=as.factor(UNRegionName), y=..count.. / sum(..count..))) +
  ggtitle("UN Region Distribution in LMICs")+
  geom_bar(fill="light blue") + 
  labs(x = "",
       y = "Proportion of subnational regions for prediction")+
  theme_bw()
Plot_UNRegionDistribution_Prediction

```

##Boot-strapping samples from training set with UN Global Regions as stratification categories
```{r}
#preparing data frame
regMatrix_SMDW <- joiningWithFeatureSets(SMDW_training, EO_features, bandNames_39) %>% 
  select(all_of("HH7_region"),all_of("NAME_0"), all_of(bandNames_39), all_of("SMDWcoverageAtRegionalLevel"),all_of("HouseholdsInRegion.Freq.x")) 

regMatrix_SMDW_UNRegionName <- joinWithCountryUNGlobalRegions(regMatrix_SMDW, UN_Population_Devision_Names, GlobalRegions) %>%  
 select(all_of(bandNames_39),UNRegionName,ISO3.Alpha.code, NAME_0, HH7_region,all_of("SMDWcoverageAtRegionalLevel"),all_of("HouseholdsInRegion.Freq.x"))

regMatrix_SMDW_UNRegionName$UNRegionName[regMatrix_SMDW_UNRegionName$NAME_0 == "Kosovo (under UNSC res. 1244)"] <- "Europe"

regMatrix_SMDW_UNRegionName <-  createColumnForCVfoldBasedOnCountries(regMatrix_SMDW_UNRegionName) %>% 
as.data.frame()

#boot-strap sampling and random forest modelling
regressionMatrices = list(100)
rf_models_SMDW = list(100)
rf_predictions = list(100)
rf_R2_CV =list(100)
rf_MAE_CV =list(100)

h2o.shutdown()
h2o.init(nthreads = 7, max_mem_size = '8g', ignore_config = TRUE)

regMatrixH2O_4pred_39 <- as.h2o(regressionMatrixForPrediction, destination_frame = "regMatrixH2O_4pred_39")
  
SMDWcoverageAtRegionalLevel <-'SMDWcoverageAtRegionalLevel'

#Sample fractions reflect the fraction of LMICs located in the corresponding UN Region

for (i in 1:100) {
  set.seed(i)
  
  africaSubSample <- regMatrix_SMDW_UNRegionName %>% 
    filter(UNRegionName == "Africa") %>% 
    sample_n(102, replace = TRUE)#fraction:0.32 
  americasSubSample <- regMatrix_SMDW_UNRegionName %>% 
    filter(UNRegionName == "Americas") %>% 
    sample_n(size=55, replace = TRUE)#fraction:0.17 
  asiaSubSample <- regMatrix_SMDW_UNRegionName %>% 
    filter(UNRegionName == "Asia") %>% 
    sample_n(size=102, replace = TRUE)#fraction:0.32 
  europeSubSample <- regMatrix_SMDW_UNRegionName %>% 
    filter(UNRegionName == "Europe") %>% 
    sample_n(size=48, replace = TRUE)#fraction:0.15 
  oceaniaSubSample <- regMatrix_SMDW_UNRegionName %>% 
    filter(UNRegionName == "Oceania") %>% 
    sample_n(size=11, replace = TRUE)#fraction:0.03
  
  regressionMatrixStratifiedByRegion <- rbind(africaSubSample, americasSubSample, asiaSubSample, europeSubSample, oceaniaSubSample)
  
  regressionMatrices[[i]] <- regressionMatrixStratifiedByRegion

regressionMatrixStratifiedByRegion <-  regressionMatrixStratifiedByRegion  %>% select(all_of(bandNames_39), all_of("SMDWcoverageAtRegionalLevel"), all_of("country_fold"), all_of("HouseholdsInRegion.Freq.x"))
  
  regMatrixH2O_StratifiedByRegion <- as.h2o(regressionMatrixStratifiedByRegion, destination_frame = "regMatrixH2O_StratifiedByRegion")
  
  
  rf_model_SMDW <- h2o.randomForest(
    y = SMDWcoverageAtRegionalLevel,
    training_frame = regMatrixH2O_StratifiedByRegion,
    ntrees = 100,
    mtries = 10,
    sample_rate = 0.6,
    min_rows = 3,
    fold_column = "country_fold",
    weights_column = "HouseholdsInRegion.Freq.x",
    seed = 0
  )
  
  rf_models_SMDW[[i]] <- rf_model_SMDW
  
  rf_R2_crossValidation <- as.data.frame(h2o.r2(rf_model_SMDW, xval = TRUE))
  rf_MAE_crossValidation <- as.data.frame(h2o.mae(rf_model_SMDW, xval = TRUE))
  
  rf_R2_CV[[i]] <- rf_R2_crossValidation
  rf_MAE_CV[[i]] <- rf_MAE_crossValidation
  
  Prediction_SMDW <- as.data.frame(h2o.predict(rf_model_SMDW, regMatrixH2O_4pred_39))
 
 rf_predictions[[i]] <- Prediction_SMDW
 
}

#Cross validation metrics
rf_R2_CV <- as.data.frame(do.call(cbind,rf_R2_CV))
rowMeans(rf_R2_CV[,1:100])# 0.466
apply(rf_R2_CV[,1:100],1, quantile, probs= 0.25)#0.425
apply(rf_R2_CV[,1:100],1, quantile, probs= 0.75)#0.512

rf_MAE_CV <- as.data.frame(do.call(cbind,rf_MAE_CV))
rowMeans(rf_MAE_CV[,1:100])#0.132
apply(rf_MAE_CV[,1:100],1, quantile, probs= 0.25)#0.125
apply(rf_MAE_CV[,1:100],1, quantile, probs= 0.75)#0.139

rf_predictions <- as.data.frame(do.call(cbind,rf_predictions))

library(matrixStats)
# calculate the mean and standard deviation for different number of random forests

rf_predictions$mean <-rowMeans(rf_predictions[,1:100]) 
rf_predictions$SD <- apply(rf_predictions[,1:100],1,sd)
rf_predictions$CoV <-rf_predictions$SD/rf_predictions$mean
rf_predictions$GID_1 <-EO_GADM_level1$GID_1
rf_predictions$GID_0 <-EO_GADM_level1$GID_0
rf_predictions$percentile25 <- apply(rf_predictions[,1:100],1, quantile, probs= 0.25)
rf_predictions$percentile75 <- apply(rf_predictions[,1:100],1, quantile, probs= 0.75)

 #write.csv(rf_predictions, "~/GitHub/MICS_SMDW/Prediction/100Bootstrap_SMDWPredictions.csv", fileEncoding = "UTF-8", row.names = F) 

#Interquartile Range, Mean and Coefficient of Variation across RF model predictions
NumberOfModels <- c(5, 10, 20, 30, 40, 50, 60, 70, 80,90, 100)
IQR <- c(rf_predictions[,1:5] %>% apply(1,IQR),
         rf_predictions[,1:10] %>% apply(1,IQR),
         rf_predictions[,1:20] %>% apply(1,IQR),
         rf_predictions[,1:30] %>% apply(1,IQR),
         rf_predictions[,1:40] %>% apply(1,IQR),
         rf_predictions[,1:50] %>% apply(1,IQR),
         rf_predictions[,1:60] %>% apply(1,IQR),
         rf_predictions[,1:70] %>% apply(1,IQR),
         rf_predictions[,1:80] %>% apply(1,IQR),
         rf_predictions[,1:90] %>% apply(1,IQR),
         rf_predictions[,1:100] %>% apply(1,IQR))

Mean <- c(rowMeans(rf_predictions[,1:5]),
         rowMeans(rf_predictions[,1:10]),
         rowMeans(rf_predictions[,1:20]),
         rowMeans(rf_predictions[,1:30]),
         rowMeans(rf_predictions[,1:40]),
         rowMeans(rf_predictions[,1:50]),
         rowMeans(rf_predictions[,1:60]),
         rowMeans(rf_predictions[,1:70]),
         rowMeans(rf_predictions[,1:80]),
         rowMeans(rf_predictions[,1:90]),
         rowMeans(rf_predictions[,1:100]))

CoV <- c(apply(rf_predictions[,1:5],1,sd)/rowMeans(rf_predictions[,1:5]),
         apply(rf_predictions[,1:10],1,sd)/rowMeans(rf_predictions[,1:10]),
         apply(rf_predictions[,1:20],1,sd)/rowMeans(rf_predictions[,1:20]),
         apply(rf_predictions[,1:30],1,sd)/rowMeans(rf_predictions[,1:30]),
         apply(rf_predictions[,1:40],1,sd)/rowMeans(rf_predictions[,1:40]),
         apply(rf_predictions[,1:50],1,sd)/rowMeans(rf_predictions[,1:50]),
         apply(rf_predictions[,1:60],1,sd)/rowMeans(rf_predictions[,1:60]),
         apply(rf_predictions[,1:60],1,sd)/rowMeans(rf_predictions[,1:70]),
         apply(rf_predictions[,1:80],1,sd)/rowMeans(rf_predictions[,1:80]),
         apply(rf_predictions[,1:90],1,sd)/rowMeans(rf_predictions[,1:90]),
         apply(rf_predictions[,1:100],1,sd)/rowMeans(rf_predictions[,1:100]))
         

rf_predictions_IQR <- data.frame(NumberOfModels,IQR, Mean, CoV)

IQR_AcrossPredictions <- ggplot(rf_predictions_IQR, 
                      aes(x = as.factor(NumberOfModels), 
                          y = IQR)) +
  geom_boxplot() +
  labs(x = "Number of Simulations",
       y = "Interquartile Range") +
  theme_minimal()

IQR_AcrossPredictions

Mean_AcrossPredictions <- ggplot(rf_predictions_IQR, 
                      aes(x = as.factor(NumberOfModels), 
                          y = Mean,)) +
  geom_boxplot() +
  labs(x = "Number of Simulations",
       y = "Average Predicted Value") +
  theme_minimal()

Mean_AcrossPredictions

CoV_AcrossPredictions <- ggplot(rf_predictions_IQR, 
                      aes(x = as.factor(NumberOfModels), 
                          y = CoV,)) +
  geom_boxplot() +
  #geom_jitter(shape=16, position=position_jitter(0.2))+
  labs(x = "Number of Simulations",
       y = "Coefficient of Variation") +
  theme_minimal()

CoV_AcrossPredictions

#write.csv(rf_predictions_IQR, "~/GitHub/MICS_SMDW/Prediction/prediction-results/IQR_CoV_Mean_ofSMDWModels_newest.csv", fileEncoding = "UTF-8", row.names = F) 
 
```

##Descriptive analysis of results

In the next section we calculate numbers of people without SMDWs and coverage rates across all LMICS, at UN region level and at national level
```{r}
rf_predictions <- read.csv("~/GitHub/MICS_SMDW/Prediction/prediction-results/100Bootstrap_SMDWPredictions.csv", fileEncoding = "UTF-8")

FullPrediction_SMDW_UNGlobalRegions <- FullPrediction_SMDW_UNGlobalRegions %>% 
  left_join(rf_predictions, by = c("GID_1"="GID_1", "GID_0"="GID_0"))

#calculating the number of people in LMICs without access to SMDW based on results from single best RF (39 features)

FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion <- FullPrediction_SMDW_UNGlobalRegions$GPWv4_Population_2020 

FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion <- FullPrediction_SMDW_UNGlobalRegions$GPWv4_Population_2020*FullPrediction_SMDW_UNGlobalRegions$predict.x

FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion <- FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion-FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion

#totalNumberOfPeopleLMICS
sum(FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion)# 6.523e+09

#Number of people without SMDWs in LMICs (based on single RF model)
sum(FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion)# 4390782308 = 67% of LMIC population

#calculating number of people in LMICs without access to SMDW average of of 100 regionally stratified RFs

FullPrediction_SMDW_UNGlobalRegions$averageNumberOfPeopleWithSMDWinRegion <- FullPrediction_SMDW_UNGlobalRegions$GPWv4_Population_2020*FullPrediction_SMDW_UNGlobalRegions$mean

FullPrediction_SMDW_UNGlobalRegions$averageNumberOfPeopleNoSMDWinRegion <- FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion-FullPrediction_SMDW_UNGlobalRegions$averageNumberOfPeopleWithSMDWinRegion

#Number of people without SMDWs in LMICs (based on average prediction of 100 RFs)
sum(FullPrediction_SMDW_UNGlobalRegions$averageNumberOfPeopleNoSMDWinRegion)# 4298207576 = 66% of LMIC population 

#calculating with 25 percentile of prediction values
FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion_IQR_25 <- FullPrediction_SMDW_UNGlobalRegions$GPWv4_Population_2020*FullPrediction_SMDW_UNGlobalRegions$percentile25

FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion_IQR_25 <- FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion-FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion_IQR_25

#Number of people without SMDWs in LMICs (based on 25 percentile of prediction values of 100 RFs)
sum(FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion_IQR_25)# 4467694882 = 68% of LMIC population

#calculating with 75 percentile of prediction values
FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion_IQR_75 <- FullPrediction_SMDW_UNGlobalRegions$GPWv4_Population_2020*FullPrediction_SMDW_UNGlobalRegions$percentile75

FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion_IQR_75 <- FullPrediction_SMDW_UNGlobalRegions$numberOfPeopleinRegion-FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleWithSMDWinRegion_IQR_75

#Number of people without SMDWs in LMICs (based on 75 percentile of prediction values of 100 RFs)
sum(FullPrediction_SMDW_UNGlobalRegions$NumberOfPeopleNoSMDWinRegion_IQR_75)# 4131923213 = 63% of LMIC population

#write.csv(FullPrediction_SMDW_UNGlobalRegions,"~/GitHub/MICS_SMDW/Prediction/prediction-results/SMDWPredictions_proportionAndNumberOfPeople_newest.csv") 

# Calculating Proportion Of LMIC population not using SMDWs at UN region level (with single best performing model predictions)

SMDW_predictions_UNregion <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(UNRegionName) %>% 
  summarise(numberOfPeopleWithNoSMDWinUNRegion = sum(NumberOfPeopleNoSMDWinRegion))

SMDW_predictions_UNregion_<- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(UNRegionName) %>% 
  summarise(numberOfPeopleinUNRegion = sum(numberOfPeopleinRegion))

SMDW_predictions_UNregion$ProportionOfRegionPopulationWithNoSMDW <- 1-(SMDW_predictions_UNregion$numberOfPeopleWithNoSMDWinUNRegion/SMDW_predictions_UNregion_$numberOfPeopleinUNRegion)

SMDW_predictions_UNregion$ProportionOfLMICpopulationWithNoSMDW <-SMDW_predictions_UNregion$numberOfPeopleWithNoSMDWinUNRegion/4390782308

#calculating the number of people without access to SMDWs at UN subregion level (results from single best RF)

SMDW_predictions_UNSubregion <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(UNSubRegionName) %>% 
  summarise(numberOfPeopleWithNOSMDWinUNSubRegion = sum(NumberOfPeopleNoSMDWinRegion))

#SMDW_predictions_UNSubregion <- SMDW_predictions_UNSubregion %>%
  #left_join(SMDW_predictions, by = c("UNSubRegionName"="UNSubRegionName"))%>%
 # dplyr::select(UNSubRegionName, numberOfPeopleWithNOSMDWinUNSubRegion, UNRegionName.x )

UNSubregion_numberSMDW <- ggplot(SMDW_predictions_UNSubregion, aes(x=reorder(UNSubRegionName, numberOfPeopleWithNOSMDWinUNSubRegion), y=numberOfPeopleWithNOSMDWinUNSubRegion)) + 
  geom_bar(stat = "identity",fill="light blue" ) + 
  scale_y_continuous(labels = label_number(suffix = " M", scale = 1e-6), limits = c(0, 1250000000))+
  labs(y = "Number of people not using SMDWs", x="") +
coord_flip() +
  theme_bw()


#calculating the proportion of people without access to SMDWs at UN subregion level (results from single best RF)

population_UNSubregion <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(UNSubRegionName) %>% 
  summarise(numberOfPeopleinUNSubRegion = sum(numberOfPeopleinRegion))

SMDW_predictions_UNSubregion$SMDWcoverage <- 1-SMDW_predictions_UNSubregion$numberOfPeopleWithNOSMDWinUNSubRegion/population_UNSubregion$numberOfPeopleinUNSubRegion

UNSubregion_coverageSMDW <- ggplot(SMDW_predictions_UNSubregion, aes(x=reorder(UNSubRegionName, 1-SMDWcoverage), y=1-SMDWcoverage, fill=UNSubRegionName)) + 
  geom_bar(stat = "identity",fill="light blue" ) + 
  labs(y = "Proportion of population not using SMDWs", x="") +
coord_flip() +
  theme_bw()

```
```{r}
# Calculating SMDWs use at National level

#from final rf model
nationalpopulationSMDWcoverage <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(country) %>% 
  summarise(numberOfPeopleNoSMDWincountry = sum(NumberOfPeopleNoSMDWinRegion)) 

#from 25 percentile of 100 rf predictions
nationalpopulationSMDWcoverage_IQR_25 <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(country) %>% 
  summarise(numberOfPeopleNoSMDWincountry_25 = sum(NumberOfPeopleNoSMDWinRegion_IQR_25)) 

#from 75 percentile of 100 rf predictions
nationalpopulationSMDWcoverage_IQR_75 <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(country) %>% 
  summarise(numberOfPeopleNoSMDWincountry_75 = sum(NumberOfPeopleNoSMDWinRegion_IQR_75))

#from average of 100 rf predictions
nationalpopulationSMDWcoverage_mean <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(country) %>% 
  summarise(averageNumberOfPeopleNoSMDWincountry = sum(averageNumberOfPeopleNoSMDWinRegion))

#calculating national SMDWs coverage (for single model, with mean and IQR of 100 models)
nationalpopulation <- FullPrediction_SMDW_UNGlobalRegions %>% 
  group_by(country) %>% 
  summarise(numberOfPeopleincountry = sum(numberOfPeopleinRegion))

#single model
nationalpopulationSMDWcoverage$nationalSMDWcoverage <- 1-nationalpopulationSMDWcoverage$numberOfPeopleNoSMDWincountry/nationalpopulation$numberOfPeopleincountry

#25 percentile
nationalpopulationSMDWcoverage_IQR_25$nationalSMDWcoverage_IQR_25 <- 1-nationalpopulationSMDWcoverage_IQR_25$numberOfPeopleNoSMDWincountry_25/nationalpopulation$numberOfPeopleincountry

#75 percentile
nationalpopulationSMDWcoverage_IQR_75$nationalSMDWcoverage_IQR_75 <- 1-nationalpopulationSMDWcoverage_IQR_75$numberOfPeopleNoSMDWincountry_75/nationalpopulation$numberOfPeopleincountry

#mean
nationalpopulationSMDWcoverage_mean$nationalSMDWcoverage_mean <- 1-nationalpopulationSMDWcoverage_mean$averageNumberOfPeopleNoSMDWincountry/nationalpopulation$numberOfPeopleincountry

#join all to single data frame
nationalpopulationSMDWcoverage_ <- nationalpopulationSMDWcoverage %>% 
left_join(FullPrediction_SMDW_UNGlobalRegions, by = c("country"="country"))%>%
left_join(nationalpopulationSMDWcoverage_IQR_25, by = c("country"="country"))%>%
left_join(nationalpopulationSMDWcoverage_IQR_75, by = c("country"="country"))%>%
left_join(nationalpopulationSMDWcoverage_mean, by = c("country"="country"))%>%
  dplyr::select(UNRegionName, UNSubRegionName, country,X.U.FEFF.Country, numberOfPeopleNoSMDWincountry, nationalSMDWcoverage, numberOfPeopleNoSMDWincountry_25, nationalSMDWcoverage_IQR_25, numberOfPeopleNoSMDWincountry_75, nationalSMDWcoverage_IQR_75, averageNumberOfPeopleNoSMDWincountry, nationalSMDWcoverage_mean) %>% unique()

#calculating proportion of population without SMDWs (for single model, with mean and IQR of 100 models)
nationalpopulationSMDWcoverage_$propotionwithoutSMDW <- 1-nationalpopulationSMDWcoverage_$nationalSMDWcoverage

nationalpopulationSMDWcoverage_$propotionwithoutSMDW_IQR_25 <- 1-nationalpopulationSMDWcoverage_$nationalSMDWcoverage_IQR_25

nationalpopulationSMDWcoverage_$propotionwithoutSMDW_IQR_75 <- 1-nationalpopulationSMDWcoverage_$nationalSMDWcoverage_IQR_75

nationalpopulationSMDWcoverage_$propotionwithoutSMDW_mean <- 1-nationalpopulationSMDWcoverage_$nationalSMDWcoverage_mean

#write.csv(nationalpopulationSMDWcoverage_,"~/GitHub/MICS_SMDW/Prediction/prediction-results/PredictionResultsNational_final_incl_mean_percentiles_newest.csv") 
```

##Comparing national estimates with JMP Data

```{r}
JMP_SMDWs <- read.csv("~/GitHub/MICS_SMDW/Data/JMP_2020_SMDWs_extracted.csv", encoding = "UTF-8") 

#joining and preparing data frame with our predictions with SMDWs estimates reported by the JMP
nationalPredictions_JMP_SMDWs <- nationalpopulationSMDWcoverage_ %>%
  left_join(JMP_SMDWs,by = c("country"="NAME_0"))

nationalPredictions_JMP_SMDWs$JMP.reported <- as.numeric(nationalPredictions_JMP_SMDWs$JMP.reported)

nationalPredictions_JMP_SMDWs$nationalSMDWcoverage_Hhlevel <- as.numeric(nationalPredictions_JMP_SMDWs$nationalSMDWcoverage)

nationalPredictions_JMP_SMDWs$nationalPopulation <- nationalPredictions_JMP_SMDWs$numberOfPeopleNoSMDWincountry/nationalPredictions_JMP_SMDWs$propotionwithoutSMDW

nationalPredictions_JMP_SMDWs_omitNA <- nationalPredictions_JMP_SMDWs %>% 
  select(-Training,-Validation,-nationalSMDWcoverage_Hhlevel) %>% 
  na.omit() %>%
  left_join(UN_Population_Devision_Names, by = c("X.U.FEFF.Country"="X.U.FEFF.Country")) %>%
  left_join(country_Income_Groups, by = c("ISO3.Alpha.code"="Code"))


#plotting   
plotPredictionVsJMP_Income <- ggplot(nationalPredictions_JMP_SMDWs_omitNA, 
                      aes(x = nationalSMDWcoverage, 
                          y = JMP.reported,size=nationalPopulation, colour=as.factor(Income.group))) +
  geom_point(shape=1) +
  labs(x = "Predicted proportion of population using SMDWs",
       y = "JMP reported proportion of population using SMDWs", col = "Income group", size= "national Population") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
 stat_smooth(se = T,
              colour = "black",
              size = 0.5,
              method = "lm") +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
   #geom_linerange(data = nationalPredictions_JMP_SMDWs_omitNA, aes(xmin = nationalSMDWcoverage_IQR_25, xmax = nationalSMDWcoverage_IQR_75, size=.3))+
  theme_bw() + scale_color_npg()

plotPredictionVsJMP_UNRegion <- ggplot(nationalPredictions_JMP_SMDWs_omitNA, 
                      aes(x = nationalSMDWcoverage, 
                          y = JMP.reported,size=nationalPopulation, colour= UNRegionName)) +
  geom_point(shape=1) +
  labs(x = "Predicted proportion of population using SMDWs",
       y = "JMP reported proportion of population using SMDWs", col = "Income group", size= "national Population") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
 stat_smooth(se = T,
             method = "lm",
             colour = "black",
             size = 0.5) +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
   #geom_linerange(data = nationalPredictions_JMP_SMDWs_omitNA, aes(xmin = nationalSMDWcoverage_IQR_25, xmax = nationalSMDWcoverage_IQR_75, size=.3))+
  theme_bw() + scale_color_npg()

#write.csv(nationalPredictions_JMP_SMDWs,"~/GitHub/MICS_SMDW/Prediction/prediction-results/nationalPredictions_JMP_SMDWs_newest.csv") 
```
## Analysis of differences in JMP estimates and random forest predictions
```{r}
#calculating difference (delta) between prediction from single RF model and JMP reported estimates
nationalPredictions_JMP_SMDWs_omitNA$delta_JMP_singlePrediction <- abs(nationalPredictions_JMP_SMDWs_omitNA$JMP.reported-nationalPredictions_JMP_SMDWs_omitNA$nationalSMDWcoverage)

#calculating difference (delta) between prediction from average across 100 RF model predictions and JMP reported estimates
nationalPredictions_JMP_SMDWs_omitNA$delta_JMP_meanPrediction <- abs(nationalPredictions_JMP_SMDWs_omitNA$JMP.reported-nationalPredictions_JMP_SMDWs_omitNA$nationalSMDWcoverage_mean)

#by UN region
delta_JMP_singlePrediction <- nationalPredictions_JMP_SMDWs_omitNA %>%
  group_by(UNRegionName) %>%
  summarise(deltaRegion_JMP_singlePrediction = mean(delta_JMP_singlePrediction))

delta_JMP_meanPrediction <- nationalPredictions_JMP_SMDWs_omitNA %>%
  group_by(UNRegionName) %>%
  summarise(deltaRegion_JMP_meanPrediction = mean(delta_JMP_meanPrediction))

#by income group

delta_JMP_singlePrediction_income <- nationalPredictions_JMP_SMDWs_omitNA %>%
  group_by(Income.group) %>%
  summarise(deltaRegion_JMP_singlePrediction = mean(delta_JMP_singlePrediction))

delta_JMP_meanPrediction_income <- nationalPredictions_JMP_SMDWs_omitNA %>%
  group_by(Income.group) %>%
  summarise(deltaRegion_JMP_meanPrediction = mean(delta_JMP_meanPrediction))

```

Comparison of final random forest model predictions to averaged prediction of 100 spatially stratified RF models
```{r}
nationalpopulationSMDWcoverage_income <- nationalpopulationSMDWcoverage_ %>%
  left_join(UN_Population_Devision_Names, by = c("X.U.FEFF.Country"="X.U.FEFF.Country")) %>%
  left_join(country_Income_Groups, by = c("ISO3.Alpha.code"="Code"))

nationalpopulationSMDWcoverage_income$Income.group[nationalpopulationSMDWcoverage_income$country == "Venezuela"] <- "Lower middle income"

#Plot national predictions of final model against those of spatially stratified model
plotPredictionFinalVs100Models_national <- ggplot(nationalpopulationSMDWcoverage_income, 
                      aes(x = nationalSMDWcoverage, 
                          y = nationalSMDWcoverage_mean, colour= Income.group)) +
  geom_point(shape=1) +
  labs(x = "Proportion of population using SMDWs (single model)",
       y = "Average proportion of population using SMDWs (100 models)", col = "Income group", size= "national Population") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
 stat_smooth(se = T,
              colour = "black",
              size = 0.5,
              method = "lm") +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
  theme_bw() + scale_color_npg()

#Plot subnational predictions of final model against those of spatially stratified model

plotPredictionFinalVs100Models_subnational <- ggplot(FullPrediction_SMDW_UNGlobalRegions, 
                      aes(x = predict.x, 
                          y = mean, colour= Income.group)) +
  geom_point(shape=1) +
  labs(x = "Proportion of population using SMDWs (single model)",
       y = "Average proportion of population SMDW (100 models)", col = "Income group", size= "national Population") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
 stat_smooth(se = T,
              colour = "black",
              size = 0.5,
              method = "lm") +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
  theme_bw() + scale_color_npg()

#Plot subnational predictions of final model against those of spatially stratified model

plotPredictionFinalVs100Models_subnational <- ggplot(FullPrediction_SMDW_UNGlobalRegions, 
                      aes(x = predict.x, 
                          y = mean, colour= Income.group)) +
  geom_point(shape=1) +
  labs(x = "Proportion of population using SMDWs (single model)",
       y = "Average proportion of population SMDW (100 models)", col = "Income group", size= "national Population") +
   coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
 stat_smooth(se = T,
              colour = "black",
              size = 0.5,
              method = "lm") +
  geom_abline(slope = 1,
              intercept = 0,
              na.rm = FALSE, 
              show.legend = NA, 
              linetype = "dashed") +
  theme_bw() + scale_color_npg()

```
```
